##  JVM的浅尝辄止



### JVM的作用

- JVM就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分
- **所有的java程序会首先经过javac被编译为.class的类文件**，这种类文件可以在虚拟机上执行。也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行（也就是将class字节码转换为机器可执行的机器码）。当然只有JVM还不能完成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库。
- JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。
- ![image-20210403191033106](http://img.codezhou.com/img/image-20210403191033106.png)



### JVM的内存区域



![Java运行时数据区域JDK1.8.png](http://img.codezhou.com/img/Java运行时数据区域JDK1.8.png)

- **程序计数器**：程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址
  - **字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制**
  - **在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了**
  - **程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**

- **虚拟机栈**：Java 虚拟机栈是描述 Java 方法运行过程的内存模型
  - Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息
  - **Java 虚拟机栈会出现两种错误：`StackOverFlowError` 和 `OutOfMemoryError`**
  - **`StackOverFlowError`：** 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。
  - **`OutOfMemoryError`：** Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常异常
- **本地方法栈**：和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
- **堆**：Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**
  - 由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：**新生代和老年代**：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等
- **方法区**：方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储**已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等**数据
  - **JDK1.8** hotspot移除了**永久代**用**元空间(**Metaspace)**取而代之, 这时候字符串常量池还在堆**, **运行时常量池还在方法区**, 只不过方法区的实现从永久代变成了元空间(Metaspace) 



### 关于方法区（元空间）

**疑惑：方法区中的Class常量池和堆中的字符串常量池有什么联系？运行时常量池是在哪里？**

- **字符串常量池**：也叫全局字符串池，**字符串常量池**里的内容是在类加载完成，经过验证，**准备阶段之后**在`堆`中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：s**tring pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的**。）。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。
- **Class文件常量池**:class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。 
- **运行时常量池**:当java文件被编译成class文件之后，也就是会生成我上面所说的class常量池,jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而**当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中**，由此可知，运行时常量池也是每个类都有一个。经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。
- 三个常量池的各个运行阶段：在该类的class常量池中存放一些符号引用，然后**类加载之后，将class常量池中存放的符号引用转存到运行时常量池中**，然后**经过验证，准备阶段之后，在堆中生成驻留字符串的实例对象（也就是上例中str1所指向的”abc”实例对象），然后将这个对象的引用存到全局String Pool中**，也就是StringTable中，最后在**解析阶段，要把运行时常量池中的符号引用替换成直接引用，那么就直接查询StringTable，保证StringTable里的引用值与运行时常量池中的引用值一致**，大概整个过程就是这样了。
- **Class常量池和运行时常量池在方法区中也就是HosSpot中的元空间里面，而字符串常量池在JDK8之后被放在了堆中**
- **总结**：
  - 1.**字符串常量池**在每个VM中只有一份，存放的是字符串常量的引用值。
  - 2.**Class常量池**是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。
  - 3.**运行时常量池**是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。

- ![img](http://img.codezhou.com/img/20171115215708642)





### 关于堆

- 堆中分**新生代**和**老年代**，新生代中分**Eden**和**Survivor**：
  - 新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ，可以通过参数 –XX:NewRatio 配置
  - Edem : from : to = 8 : 1 : 1 ， 可以通过参数 –XX:SurvivorRatio 来设定
  - Survivor区中的对象被复制次数为15(对应虚拟机参数 -XX:+MaxTenuringThreshold)
- **疑惑1**：**堆中为什么要分为新生代和老年代?**
  - 一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。
  - **比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**
- **疑惑2**：**那么新生代中再细分Eden区和Survivor区的好处?**
  - urvivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选
    保证，一般情况经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代
  - 因为新生代采用了复制算法回收垃圾，有两个Survivor区保证了经历过一次GC之后有一个Survivor区域是空的



### 关于GC（垃圾回收）

**GC的分类：Minor GC，Major GC，full GC**

- **垃圾回收的大概流程：**

  - **当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC**，以收集新生代的垃圾，存活下来的对
    象，则会转移到 Survivor区。
  - 大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年代；
  - 如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为
    1，每熬过一次Minor GC，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。即长期存
    活的对象进入老年态。
  - **老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代。**
  - **Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。**
  - ![image-20210404191028878](http://img.codezhou.com/img/image-20210404191028878.png)

  

- **常见的垃圾回收算法：**

  - **标记-清除算法**：该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。
    - 缺点：效率问题和会产生内存碎片
  - **复制算法**：**为了解决效率问题**，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。
  - **标记-整理算法**：根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是**让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存**，避免内存碎片的问题
  - **分代收集算法**

  

- **如何判断对象是否死亡**

  - **引用计数法**

    - **在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的**。
    - 缺点：在两个对象出现循环引用的情况下，此时计数器永远不为0，导致无法对它进行回收

  - **可达性算法**

    - 这个算法的基本思想是通过一系列称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的

    

- **常见的垃圾收集器**

  - Serial收集器： 单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。
  - ParNew收集器： Serial收集器的多线程版本，也需要stop the world，复制算法。
  - Serial Old收集器： 是Serial收集器的老年代版本，单线程收集器，使用标记整理算法。
  - Parallel Old收集器： 是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法
  - **CMS(Concurrent Mark Sweep) 收集器**： 是一种以获得最短回收停顿时间为目标的收集器，**标记清除算法**，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片。
  - **G1收集器**： **标记整理算法实现**，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选标记。不会产生空间碎片，可以精确地控制停顿

  

- **CMS收集器和G1收集器的区别**
  - **CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片**
  - **G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。**
  - CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；
  - G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；
  - CMS收集器以最小的停顿时间为目标的收集器；
  - G1收集器可预测垃圾回收的停顿时间



### 关于类加载器以及双亲委派模型

- **类加载器**： 就是**根据指定全限定名称将class文件加载到JVM内存，转为Class对象**

  - 启动类加载器（**Bootstrap ClassLoader**）：由C++语言实现（针对HotSpot）,负责将存放在
    <JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。
  - 其他类加载器：由Java语言实现，继承自抽象类ClassLoader。如：
  - 扩展类加载器（**Extension ClassLoader**）：负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。
  - 应用程序类加载器（**Application ClassLoader**）。负责**加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。**

  

- **双亲委派模型**
  双亲委派模型工作过程是：

  - 如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，
  - 而是把这个请求委派给父类加载器完成。每个类加载器都是如此
  - **只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。**
  - ![image-20210419160531599](http://img.codezhou.com/img/image-20210419160531599.png)



- **为什么需要双亲委派模型？**
  如果没有双亲委派，那么用户是不是可以自己定义一个java.lang.Object的同名类，java.lang.String的同名类，并把它放到ClassPath中,那么类之间的比较结果及类的唯一性将无法保证，因此，为什么需要双亲委派模型？**保证了运行的安全性，防止不可信类扮演可信任的类**



- **怎么打破双亲委派模型？**
  打破双亲委派机制则不仅要继承ClassLoader类，还要重写loadClass和findClass方法。



### 关于四个引用

- **强引用**
  **我们平时new了一个对象就是强引用**，例如 Object obj = new Object();即使在内存不足的情况下，**JVM**
  **宁愿抛出OutOfMemory错误也不会回收这种对象。**

- **软引用**
  **如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会**
  **回收这些对象的内存。**

  ```java
  SoftReference<String> softRef=new SoftReference<String>(str);   // 软引用
  ```

  - 用处： 软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容
    是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。
    （1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构
    建
    （2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出

  - 如下代码：

    ```java
    Browser prev = new Browser();        // 获取页面进行浏览
    SoftReference sr = new SoftReference(prev); // 浏览完毕后置为软引用    
    if(sr.get()!=null){
    rev = (Browser) sr.get();      // 还没有被回收器回收，直接获取
    }else{
    prev = new Browser();        // 由于内存吃紧，所以对软引用的对象回收了
     sr = new SoftReference(prev);    // 重新构建
    }
    ```

- **弱引用**
  具有弱引用的对象拥有更短暂的生命周期。**在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦**
  **发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存**。

- **虚引用**
  如果一个对象仅持有虚引用，**那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚**
  **引用主要用来跟踪对象被垃圾回收器回收的活动。**



- ### 参考文章

  - https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md
  - https://blog.csdn.net/qq_26222859/article/details/73135660
  - https://blog.csdn.net/weixin_43538934/article/details/86707053
  - 以及网上一些PDF资料