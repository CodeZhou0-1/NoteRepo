#  Java序列化和序列化UID的作用

## 1. 序列化

### 1.1 概念
 - 对象序列化就是将对象的状态转化成字节流，以后可以通过这些值再生成相同状态的对象。
 - 对象序列化是对象持久化的一种实现方法，它是将对象的属性和方法转化为一种序列化的形式用于存储和传输。
 - 反序列化就是根据这些保存的信息重建对象的过程。
 - 概括为
序列化：将java对象转化为字节序列的过程。
反序列化：将字节序列转化为java对象的过程。

### 1.2 为什么Java类要序列化

>序列化是一种用来处理对象流的机制 ，所谓对象流就是将对象的内容进行流化，**可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间**；序列化是为了解决在对对象流进行读写操作时所引发的问题，将对象的状态信息转换为可以存储或传输的形式的过程。

### 1.3 什么时候Java类需要实现序列化
- 对象序列化可以实现分布式对象。主要应用例如：**RMI(即远程调用Remote Method Invocation)要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。**
- java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。**可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。**
- **序列化可以将内存中的类写入文件或数据库中。**


### 1.4 当类中有些属性不需要被序列化时
> 在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。

## 2. Java序列化ID的作用
### 2.1 概念
> 其实，这个序列化ID起着关键的作用，**它决定着是否能够成功反序列化**！简单来说，java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地实体类中的serialVersionUID进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。

### 2.2 serialVersionUID如何产生以及为什么在类中加上这个变量
 - **当我们一个实体类中没有显示的定义一个名为“serialVersionUID”、类型为long的变量时，Java序列化机制会根据编译时的class自动生成一个serialVersionUID作为序列化版本比较**，这种情况下，只有同一次编译生成的class才会生成相同的serialVersionUID。
 - 譬如，当我们编写一个类时，随着时间的推移，我们因为需求改动，需要在本地类中添加其他的字段，这个时候再反序列化时便会出现serialVersionUID不一致，导致反序列化失败。那么如何解决呢？
 - 解决办法为**在本地类中添加一个“serialVersionUID”变量，值保持不变，便可以进行序列化和反序列化。**

## 3.文章来源
**以上知识点截取自以下博客：**
https://blog.csdn.net/baidu_37107022/article/details/76860371
https://blog.csdn.net/thinkingcao/article/details/75133183